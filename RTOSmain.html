<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creating a Bare-Metal RTOS for STM32</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header>
        <h1>Creating a Bare-Metal RTOS for STM32</h1>
        <nav>
            <a href="index.html">Home</a> |
            <a href="about.html">About</a>
        </nav>
    </header>

    <main>
        <section>
            <h2>Overview</h2>
            <p>The aim of this project is to create a 'mini RTOS' for STM32 from scratch without using any hardware-abstraction.
                Essentially I am aiming to create a pre-emptive kernel including features like context-switching, task scheduling 
                and possibly semaphores This will be written for and demonstrated on the STM32 Nucleo-F401RE. I am hoping that this will
                give me good knowledge in embedded C, the STM32 microcontroller family and the Arm architecture.
            </p>

            <p> I am expecting this project to take a long time, as I have to prioritise university coursework, exams, 
                and my individual third-year project. As such I will use this page to list any milestones/steps I complete.
            </p>
           
            <h2> As of 06/10/25 </h2>
            <ul>
                <li>Configured interrupts with the SysTick timer and used it to blink an LED.</li>
                <li>Used the SysTick timer to create a general timebase (1ms).</li>
                <li>Created a blocking delay function using this timebase.</li>
                <li> Implemented non-blocking delays using this timebase by polling.</li>
                <li> Created simple cooperative, non-preemptive scheduler</li>
            </ul>

        </section>

        <section> 
            <h2> Simple Cooperative Scheduler </h2> 
            <p> 
                A big foundational step towards building a custom RTOS was moving from delays to a simple non-preemptive scheduler.
                I replaced delay loops with a cooperative task system, this allowed multiple functions to run at independent delays 
                using the shared timebase from SysTick. These tasks have to be periodic.
            </p>

            <p> 
                The SysTick timer generates an interrupt every 1ms, maintaning a timebase. Tasks are represented by a Task Control Block,
                containing the tasks period, a function pointer pointing to the function the task will execute, and the time elapsed since the last execution.
                Tasks are stored in an array of a fixed size. Priorities are given to the tasks by the order in which they appear in the array.
            </p>

            <pre> <code class="language-cpp"> 

                #define TOTAL_TASKS 3

                typedef struct TaskType{				// Task Control Block structure (TCB)

	                uint32_t period;		// time between runs
	                uint32_t elapsedTime;	// time since last run
	                void (*TaskPtr)(void);	// function ptr points to task function
                } TaskType ;

                extern TaskType TaskList[TOTAL_TASKS];  // references array holding the tasks

            </code></pre>

            <p> 
                The scheduler function is called in the main loop. It iterates through each task in the list. 
                For each task, if that tasks elapsed time is greater than its period, the task is executed and elapsed time 
                is reset. The scheduler function also computes how many ms have passed since the last call and updates elapsed time
                with that number. This helps to make the scheduler robust and tasks stay in sync with real time even if loop execution time changes.
            </p>

            <pre> <code class="language-cpp">
            void scheduler(void){

                static uint32_t last_time = 0;
                uint32_t now = systick_ms;
                uint32_t time_difference = now - last_time;
                last_time = now;

                uint8_t i = 0;
                for (i=0; i<TOTAL_TASKS; i++){	

                    if(TaskList[i].elapsedTime >= TaskList[i].period){	// if elapsed time > period

                        TaskList[i].TaskPtr();		// call the tasks function
                        TaskList[i].elapsedTime = 0;	// reset elapsed time
                    }
                    TaskList[i].elapsedTime += time_difference;
                }
            }

            </code> </pre>

        </section>

        
        <section>
            <a href="https://github.com/jamieashton22/stm-rtos" target="_blank">View on GitHub</a>
        </section>
    </main>

    <footer>
        <p>October 2025 Jamie Ashton</p>
    </footer>
</body>
</html>
